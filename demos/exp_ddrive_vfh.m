% Experiment setup for Exercise 2: 
% Extende Kalman Filter based localization of a Differential Drive Mobile
% Robot
function exp = exp_ddrive_vfh() 
    exp = experiment_base('vfh');
        
    scenario = 3;
    
    % Prepare map and path for office environment experiment setup

	exp.environment = grp_obstacles_and_landmarks_from_image('../maps/office.png', 'scale', 0.01);        
    switch scenario
        case 1
            pathPoints = [1.00,   0.50;...
                          1.00, 4.30;...
                          2.60, 4.30;...
                          2.60, 2.70;...
                          6.00, 2.70;... 
                          6.00, 5.10;...
                          7.00, 5.10;...
                          6.00, 5.10;...
                          6.00, 3.30;...
                          7.50, 2.70;...
                          7.50, 0.75;...
                          5.00, 1.50;...
                          2.00, 1.50;...
                          2.00, 0.50];
        case 2
            pathPoints = [1.00,   0.50;...
                          2.60, 4.30;...
                          6.00, 2.70;... 
                          7.00, 5.10;...
                          6.00, 3.30;...
                          7.50, 0.75;...
                          5.00, 1.50;...
                          2.00, 0.50];
        case 3
            pathPoints = [1.00,   0.50;...
                          2.00, 4.30;...
                          6.00, 2.70;... 
                          7.00, 5.10;...
                          6.00, 3.30;...
                          5.00, 1.50;...
                          2.00, 0.50];
		case 4
			pathPoints = [2.00, 1.14; ...
						  5.00, 1.14];	
		otherwise
            error('Unknown scenario selected');
    end
    
    exp.robot.path = const_points(pathPoints);
    exp.robot.path.format = {'Color', [0 0 1], 'Marker', 'x'};
    
    exp.robot.initialPose = [pathPoints(1, :), 90 * pi / 180];
    
    % instantiate the platform (differential drive) and set its parameters
    exp.robot.platform = model_platform2d_ddrive();
    exp.robot.radius = 0.14;
    exp.robot.color = [0 0 1];
    exp.robot.wheelRadius = [0.03 0.03];
    exp.robot.wheelDistance = 0.25;    
        
    % add the sensors
    exp.robot.sensors.rangefinder = sensor_rangefinder2d();
    exp.robot.maxRange = 3;
    
    exp.robot.sensors.odometer = sensor_odometer_wheelspeed();
    exp.robot.odometryError = 10 * pi / 180;        

    % the robot is controlled by the extended Vector Field Histogram (VFH+)
    % algorithm
    exp.robot.controller = guidance_vfh_ddrive();
    exp.robot.controller.depends{1} = 'targetProvider';
    % Another control 'layer' that provides an intermediate goal for VHF+
    exp.robot.targetProvider = guidance_waypoints();        
    exp.robot.targetProvider.relative = true;
    
    
    exp.display.title = 'Guidance/Collision Avoidance using the Vector Field Histogram (VFH+) algorithm';       
    exp.display.settings = {'XGrid', 'on', 'YGrid', 'on', 'Layer', 'top', 'XLim', [0 8], 'YLim', [0 6]};
end